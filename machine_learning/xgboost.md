分享

1. 节点划分
   1. 特征选择？带权的候选节点选择，有疑问。
2. 特征
   1. 缺失值处理
   2. 稀疏数据处理： 缺失数据会被划分到一个默认的方向，有加速左右，速度提升50倍左右。
3. 加速
   1. 并行计算： 针对每一列进行预排序，对每一列的排序结果存储在一个block中。对后续列集合进行计算增益时，可以并行进行。
      1. log(n)： n为样本数量，预排序可以均瘫该部分消耗
      2. log(q)： q为特征候选集合的大小，还不太懂。
   2. 缓存感知： block_size过小，影响并行化的效率。过大导致梯度统计无法一次性完全放进cpu的缓存中
   3. block for out-of-computer
      1. block压缩，解压
      2. block共享： 同一个block存储多份，使用不同的线程同时去读，加快速度。
4. 参数映射
5. 分类树







其加权的意义在于，把候选节点选取的机会更多地让于二阶导更大的地方，同时忽略导数差异小的节点。





不同于基本的穷举算法，paper指出两种近似算法：一种是全局算法，即在初始化tree的时候划分好候选节点，并且在树的每一层都使用这些候选节点；另一种是局部算法，即每一次划分的时候都重新计算候选节点。这两者各有利弊，全局算法不需要多次计算候选节点，但需要一次获取较多的候选节点供后续树生长使用，而局部算法一次获取的候选节点较少，可以在分支过程中不断改善，即适用于生长更深的树，两者在effect和accuracy做trade off。

局部算法：这个k分位点的选取是近似的，不能像遍历一样保证取到的split value是最佳的split value。不过经过试验，k取到3的时候，算法性能就已经相差无几了，见下图：

 

![XGBoost之分位点算法](https://upload-images.jianshu.io/upload_images/1670295-04b7f0115030729b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/428/format/webp)

 





实验中发现，全局k分位点取20和局部k分位点取3，得到了近似的效果。

